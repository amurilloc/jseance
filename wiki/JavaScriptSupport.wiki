#summary JSeance Embedded JavaScript Support
#sidebar TableOfContents

 = Embedding !JavaScript Code in Templates =

It's possible to embed !JavaScript code in any attribute or text node of a JSeance template. For example, the following template will write the current date to a file:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<Template xmlns:JSeance="http://www.codeseance.com/JSeance" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.codeseance.com/JSeance">
 <FileOutput fileName="test.txt">
  <Text>@JavaScript{Date()}@</Text>
 </FileOutput>
</Template>
}}}

Template attributes can also include !JavaScript code, the following example declares a var in !JavaScript and then uses it in the fileName attribute to specify the file to write. This can be extended to generate fileNames based on XML model data and to generate a variable number of files from a single template.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<Template xmlns:JSeance="http://www.codeseance.com/JSeance" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.codeseance.com/JSeance">
 <JavaScript>var fileNameVar = 'file.txt';</JavaScript>
 <FileOutput fileName="@JavaScript{fileNameVar}@">
  <Text>TestOutput</Text>
 </FileOutput>
</Template>
}}}

!JavaScript code fragments are evaluated immediately before the node begins execution, this allows customization and parametrization of all template elements based on the global !JavaScript context, which is unique maintains its state during the execution lifetime of the template.

 = JSeance Object Model =
 
During a template execution, the JSeance engine defines arbitrary !JavaScript objects to make certain context information available to scripting.

 == XML Models ==

The following example illustrates the use of the 'Models' !JavaScript Object:

XML Model file (model.xml):
{{{
<?xml version="1.0" encoding="UTF-8"?>
<RootNode>
 <A attribute1="first ">
  <B attribute2="second" />
 </A>
</RootNode>
}}}

The JSeance  template:
{{{
<?xml version="1.0" encoding="UTF-8"?>
<Template xmlns:JSeance="http://www.codeseance.com/JSeance" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.codeseance.com/JSeance">
 <Model fileName="model.xml" e4XPath="A.B"/>
 <FileOutput fileName="test.txt">
  <Text>@JavaScript{Models['default'].rootNode.A.@attribute1}@</Text>
  <Text>@JavaScript{Models['default'].currentNode.@attribute2}@</Text>
 </FileOutput>
</Template>
}}}

Output file contents (test.txt):
{{{
first second
}}}

The 'Models' object contains all the models available in the context. Each model has 'currentNode' and 'rootNode' attributes. The 'currentNode' attribute can change depending on the model e4XPath attribute or when an [NodeTypes#OutputIterator OutputIterator] node is being used.

 == Definitions ==

The following example shows how to access Definitions from script:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<Template xmlns:JSeance="http://www.codeseance.com/JSeance" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.codeseance.com/JSeance">
 <Definition name="MyDefinition">
  <Text>Definition Value</Text>
 </Definition>
 <FileOutput fileName="test.txt">
  <Text>@JavaScript{Definitions['MyDefinition']}@</Text>
 </FileOutput>
</Template>
}}}


Output file contents (test.txt):
{{{
Definition Value
}}}

 = E4X Reference =

Example XML:
{{{
var myXML = <RootNode>
 <Child attribute="child attribute">
  <A attribute="first">Text Value</A>
  <B attribute="second" />
  <C attribute="third"> Concatenated</C>
 </Child>
</RootNode>;
}}}

|| *Expression* || *Value* || *Description* ||
|| {{{myXML.Child[0].@attribute}}} || {{{first}}} || Child nodes can be referenced by index ||
|| {{{myXML.Child.B.@attribute}}} || {{{second}}} || Child nodes can be referenced by tagName||
|| {{{myXML['Child']['B'].attribute['attribute']}}} || {{{second}}} || Explicit navigation||
|| {{{myXML.Child[0].toString()}}} || {{{Text Value}}} || Node to string conversion ||
|| {{{myXML.Child[0].toXMLString()}}} || {{{<A attribute="first">Text Value</A>}}} || Node to XML string conversion ||
|| {{{myXML.Child.*.(@attribute == "third").toXMLString()}}} || {{{<C attribute="third" />}}} || filter by attribute value ||
|| {{{myXML.Child.B.localName()}}} || {{{B}}} || Node local node name ||
|| {{{myXML.Child.B.name()}}} || {{{B}}} || Node full name||
|| {{{myXML.Child.*.length()}}} || {{{3}}} || Node size ||
|| {{{myXML.Child.B.parent().name()}}} || {{{Child}}} || Accessing node parents ||
|| {{{myXML.Child.text()}}} || {{{Text Value Concatenated}}} || Concatenate child text values||
|| {{{for each(var child in myXML.Child.chindren())}}} || {{{N/A}}} || Iteration through child nodes ||

Full specification: [http://www.ecma-international.org/publications/standards/Ecma-357.htm ECMA-357]

A great guide can be found [http://wso2.org/project/mashup/1.5.2/docs/e4xquickstart.html here].

[NodeTypes Prev: Node Types] [PuttingItAllTogether Next: Putting it all together: Example]